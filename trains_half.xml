<?xml version="1.0" encoding="utf-8"?><!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_1.dtd'><nta><declaration>// Place global declarations here

const int LIGHTS = 2;
const int TRAINS = 2;
const int SWITCHES = 1;


typedef int[0,TRAINS-1] t_id;
typedef int[0,LIGHTS-1] l_id;
typedef int[0,SWITCHES-1] s_id;


urgent broadcast chan init_all;

//To find the next position, we need the current direction and position of the train.
typedef struct{
//	bool hasLight;
	bool dir;
	int pos;
	bool on; //true means green
} Light;

typedef struct{
	bool switch; //If there is a switch or not
	bool switchDir; //Direction of the switch. True means there are two ways to the right.
	bool switchUp; //If switch is up or straight. True means it is angled.
	int position; 
	int nextPosRight; 
	int nextPosLeft; 
	int nextPosSwitch; //Switch default way is where it is not angled
	int timeInPos;
	Light stopLightRight;
	Light stopLightLeft;
} Node;

typedef struct{
	int pos;
	int goal;
	bool dir;
} STrain;

Node graph[4];

Light lights[LIGHTS];
STrain trains[TRAINS];

int switches[SWITCHES]; // Position of switch


void updateLight(l_id id, bool on){
	int pos = lights[id].pos;
	bool dir = lights[id].dir;

	if(pos != 0){
		if(dir){ //Right side
			graph[pos-1].stopLightRight.on = on;
		}else{
			graph[pos-1].stopLightLeft.on = on;
		}
	}

}

bool canSwitch(s_id id){


	//Can only move a switch if there is no train on it
	int i;

	for(i = 0; i &lt; TRAINS; i++){
		if(trains[i].pos == switches[id]) return false;
	}

	return true;
}


void updateSwitch(s_id id, bool angled){


	graph[switches[id]-1].switchUp = angled;	

}


bool canMove(t_id id){ //We here see if there is a stop light on

	int pos = trains[id].pos;
	int dir = trains[id].dir;

	//if(pos == trains[id].goal) return false;

	if(pos != 0){
		Node current = graph[pos-1];

		if(dir = true){ //Going right
			Light light = current.stopLightRight;
			return light.on;
		}else{
			Light light = current.stopLightLeft;
			return light.on;
		}

	}

	return false;
}

bool trainCrashed(t_id id){

	int pos = trains[id].pos;
	int goal = trains[id].goal;
	bool dir = trains[id].dir;


	int i;

	Node node;

	Node nextNode;

	if(pos == trains[id].goal) return false;

	if(pos == 0) return true;

	//Check that no two trains are at the same point
	

	node = graph[pos-1];
	//Train cashed if it is on a switch where it came from a point which was not the same way as the switch.
	for (i= 0; i &lt; TRAINS; i++){
		if(trains[i].pos == pos &amp;&amp; pos != trains[id].pos){
			return true;
		}
	}



	if(dir){ //Moving right
		//First check if light is on:
		if(!graph[pos-1].stopLightRight.on) return false;
		if(node.nextPosRight != 0){
			nextNode = graph[node.nextPosRight-1];
		}
	}else{
		if(!graph[pos-1].stopLightLeft.on) return false;
		if(node.nextPosLeft != 0){
			nextNode = graph[node.nextPosLeft-1];
		}
	}




	if( nextNode.switch){ //If it is a switch it can be the wrong way.
		if(nextNode.switchDir != dir){
			if(nextNode.switchUp){ //If switch is angled
				if(nextNode.nextPosSwitch != pos){//If not the right place
					return true;
				}
			}else{
				if(dir){
					if(nextNode.nextPosLeft != pos){//If not the right place
						return true;
					}
				}else{
					if(nextNode.nextPosRight != pos){//If not the right place
						return true;
					}
				}
			}
		}
	}

	return false;
}



bool initGraph(){//All lights are red as default. If there is no light, it is green


	Light tl =  {0,0,1}; //Dir, pos, on

	STrain train1 = {1,4,true}; //Moving right
	STrain train2 = {4,3,false}; //Moving left


	Light lights20 = {1,1,0};
	Light lights10 = {0,3,0};



	Node s20 = {0,0,0,1,2,0,0,5,lights20,tl};
	Node s11 = {1,0,0,2,4,3,1,5,tl,tl};
	Node s10 = {0,0,0,3,2,0,0,5,tl,lights10};
	Node s12 = {0,0,0,4,0,2,0,5,tl,tl};

	switches[0] = 2;

	lights[0] = lights20;
	lights[1] = lights10;

	graph[0] = s20;
	graph[1] = s11;
	graph[2] = s10;
	graph[3] = s12;


	trains[0] = train1;
	trains[1] = train2;


	return true;

}


int newPos(t_id id){
	bool dir = trains[id].dir;
	int curPos = trains[id].pos;
	int nextPos = 0;

	if(curPos &gt; 0 &amp;&amp; curPos &lt; 5){
	
		Node curNode = graph[curPos-1]; //-1 as we use place 0 as a special place	

		if(!curNode.switch){//If not a switch we move in the right way.
			if(dir){ //When going right
				nextPos = curNode.nextPosRight;
			}else{
				nextPos = curNode.nextPosLeft;
			}
		}else{//If it is a switch, we need to know if we go the right direction and what position the switch is

			if (curNode.switchDir == dir){ //When branch out is in the same direction as train is going
				if(curNode.switchUp){ //When switch is alternative track
					nextPos = curNode.nextPosSwitch;
				}else{
					if(dir){ //When going right
						nextPos = curNode.nextPosRight;
					}else{
						nextPos = curNode.nextPosLeft;
					}
				}
			}else{
				if(dir){ //When going right
					nextPos = curNode.nextPosRight;
				}else{
					nextPos = curNode.nextPosLeft;
				}
			}
		}
	}

	trains[id].pos = nextPos;
	return nextPos;
}


</declaration><template><name x="5" y="5">Train</name><parameter>t_id id</parameter><declaration>// Place local declarations here.
//int pos;
clock time;

urgent broadcast chan go;</declaration><location id="id0" x="-312" y="-104"><name x="-322" y="-134">Init</name></location><location id="id1" x="0" y="48"><name x="-16" y="16">Crash</name></location><location id="id2" x="192" y="-24"><name x="176" y="-56">Move</name><label kind="invariant" x="184" y="-80">time &lt;=10</label></location><location id="id3" x="-176" y="-32"><name x="-192" y="-64">Stop</name></location><init ref="id0"/><transition action=""><source ref="id0"/><target ref="id3"/><label kind="synchronisation" x="-264" y="-96">init_all?</label></transition><transition controllable="false" action=""><source ref="id2"/><target ref="id2"/><label kind="guard" x="240" y="-24">canMove(id) and time == 10</label><label kind="assignment" x="240" y="-48">newPos(id), time = 0</label><nail x="232" y="-48"/><nail x="232" y="-16"/></transition><transition controllable="false" action=""><source ref="id2"/><target ref="id1"/><label kind="guard" x="56" y="24">trainCrashed(id)</label><label kind="synchronisation" x="36" y="-3">go!</label></transition><transition controllable="false" action=""><source ref="id3"/><target ref="id1"/><label kind="guard" x="-192" y="24">trainCrashed(id)</label><label kind="synchronisation" x="-148" y="-7">go!</label></transition><transition controllable="false" action=""><source ref="id2"/><target ref="id3"/><label kind="guard" x="-32" y="-56">!canMove(id)</label><label kind="synchronisation" x="-56" y="-48">go!</label><nail x="40" y="-8"/><nail x="-40" y="-8"/></transition><transition controllable="false" action=""><source ref="id3"/><target ref="id2"/><label kind="guard" x="-80" y="-112">canMove(id)</label><label kind="synchronisation" x="48" y="-96">go!</label><label kind="assignment" x="24" y="-120">time = 0</label><nail x="-24" y="-80"/><nail x="24" y="-80"/></transition></template><template><name>InitGraph</name><location id="id4" x="-24" y="-64"></location><location id="id5" x="-88" y="-80"><name x="-98" y="-110">Initialized</name></location><location id="id6" x="-192" y="-80"><committed/></location><init ref="id6"/><transition><source ref="id4"/><target ref="id5"/><nail x="-72" y="-16"/></transition><transition><source ref="id5"/><target ref="id4"/></transition><transition action=""><source ref="id6"/><target ref="id5"/><label kind="synchronisation" x="-176" y="-104">init_all!</label><label kind="assignment" x="-160" y="-144">initGraph()</label></transition></template><template><name>LightA</name><parameter>l_id id</parameter><location id="id7" x="64" y="-48"><name x="54" y="-78">Green</name></location><location id="id8" x="-96" y="-48"><name x="-106" y="-78">Red</name></location><init ref="id8"/><transition action=""><source ref="id7"/><target ref="id8"/><label kind="assignment" x="-112" y="-16">updateLight(id,0)</label><nail x="24" y="-24"/><nail x="-56" y="-24"/></transition><transition action=""><source ref="id8"/><target ref="id7"/><label kind="assignment" x="-112" y="-104">updateLight(id,1)</label></transition></template><template><name>SwitchA</name><parameter>s_id id</parameter><location id="id9" x="0" y="-40"><name x="-10" y="-70">Angled</name></location><location id="id10" x="-128" y="-40"><name x="-168" y="-72">Straight</name></location><init ref="id10"/><transition action=""><source ref="id9"/><target ref="id10"/><label kind="guard" x="-120" y="16">canSwitch(id)</label><label kind="assignment" x="-136" y="0">updateSwitch(id, 0)</label><nail x="-40" y="-8"/><nail x="-104" y="-8"/></transition><transition action=""><source ref="id10"/><target ref="id9"/><label kind="guard" x="-120" y="-88">canSwitch(id)</label><label kind="assignment" x="-144" y="-104">updateSwitch(id, 1)</label><nail x="-104" y="-64"/><nail x="-40" y="-64"/></transition></template><system>// Place template instantiations here.
//Train1 = Train(1,4,true);
//Train2 = Train(4,3,false);

//l1 = LightA(1,1);
//l2 = LightA(3,0);


// List one or more processes to be composed into a system.
system Train, InitGraph, LightA, SwitchA;</system></nta>